=>Array Rotations :

rotate array by d elements
	->gcd way
	->left reversal algo
	->right reversal algo
find pivot element in sorted and rotated array
find sum of pair of numbers in sorted and rotated array
majority element	-> hashmap, moore voting algo
Lexicographically minimum string rotation	-> array of size 26,count occurence of character from A-Z
--Rotate Matrix Elements (shift all elements by 1)
--Print a given matrix in spiral form
--Inplace rotate square matrix by 90 degrees -> rotate -> transpose
--TODO--Rotate each ring of matrix anticlockwise by K elements
Check if all rows of a matrix are circular rotations of each other -> append array to array itself
Minimum rotations required to get the same string -> same as above
Check if strings are rotations of each other or not
Count rotations divisible by 4


=>Array rearrangement
Rearrange an array such that arr[i] = i
Move all negative numbers to beginning and positive to end
Rearrange array such that arr[i] >= arr[j] if i is even and arr[i]<=arr[j] if i is odd and j < i
Convert array into Zig-Zag fashion
Rearrange array in alternating positive & negative items with O(1) extra space  -> quick sort logic
Rearrange array such that even positioned are greater than odd
Rearrange an array such that ‘arr[j]’ becomes ‘i’ if ‘arr[i]’ is ‘j’
Arrange given numbers to form the biggest number
--Longest Bitonic Subsequence
--Minimum swaps required to bring all elements less than or equal to k together
--Find a sorted subsequence of size 3 in linear time
--Largest subarray with equal number of 0s and 1s



=>Optimization Problems :
--Find the smallest positive integer value that cannot be represented as sum of any subset of a given array
Smallest subarray with sum greater than a given value
Find subarray with given sum (Nonnegative Numbers)
--Find subarray with given sum (array having negative numbers)


--Print all subarrays with 0 sum




----------------------------------------------------------------------

int findPivot(int arr[]) {
	return findPivot(arr, 0, arr.length-1);
}

private findPivot(int arr[], int start, int end) {
	if(start > end) {
		return -1;
	}
	if(start == end) {
		return start;
	}
	int mid = (end-start)/2 + start;
	if( (arr[mid-1] < arr[mid]) && (arr[mid] > arr[mid+1]) ) {
		return mid;
	}
	if(arr[mid-1] < arr[mid] < arr[mid+1]) {
		return findPivot(arr, mid+1, end);
	}
	else {
		return findPivot(arr, start, mid-1);
	}
}



//Rearrange an array such that arr[i] = i
int place(int arr[]) {
	int i=0;
	while(i < arr.length) {
		if(arr[i] == -1) {
			i++;
		} else {
			if(arr[i] != i) {
				int temp = arr[arr[i]];
				arr[arr[i]] = arr[i];
				arr[i] = temp;
			} else {
				i++;
			}
		}
	}
}


//Move all negative numbers to beginning and positive to end
void moveNegativeToStart(int arr[]) {
	int i=-1;
	int j=0;
	while(j < arr.length) {
		if(arr[j] < 0) {
			i++;
			swap(arr, i, j);
		}
		j++;
	}
}


//Rearrange an array such that ‘arr[j]’ becomes ‘i’ if ‘arr[i]’ is ‘j’
void replace(int arr[]) {
	int i=0;
	while(i < arr.length) {
		if(arr[i] != i) {
			replaceInternal(arr, i);
		} else {
			i++;
		}
	}
}

void replaceInternal(int arr[], int i) {
	if(arr[i] != i) {
		int j = arr[arr[i]];
		arr[i] = i;
		replaceInternal(arr, j);
	}
}

