Graph_notes

https://www.arangodb.com/2016/04/index-free-adjacency-hybrid-indexes-graph-databases/
https://www.quora.com/What-is-the-internal-architecture-of-graph-databases-such-as-Titan-or-Neo4j
http://stackoverflow.com/questions/5604338/how-graph-databases-store-data-to-a-persistent-storage

undirected graph terminologies :

=>adjacent vertices : vertices joined by an edge
=>degree : no of edges connected to a vertex
=>sum of degree of all vertices = 2 * (no. of edges)
=>Path : a sequence of vertices v1,v2,...vn where vi and vi+1 has an edge
=>simple path, cyclic path
=>connected graph : every two vertices must have a path
=>Subgraph : a grapgh subset of vertices and subset of edges
=>Maximum connected subgrapgh : a subgrapgh, in which if u add a vertex , u cannot get a connected subgraph
=>Tree (free tree) : connected graph without cycles, different from Tree DS as they have no root node.
=>Forest : collection of trees
=>Complete graph : there is an edge bw every pair of vertices
	How many edges in a complete graph : nC2 = n*(n-1)/2
	How many edges in a complete directed graph : 2 * nC2 = n*(n-1)
=>Minimum no of edges required to make a graph connected = n-1
=>Spanning tree : subgraph which is a tree and contains all vertices

Data structures for graphs :

1) Edge list
unordered list of vertices and edges
simple to implement
inefficient when finding an edge bw two given vertices

2) Traditional Adjacency list :
vertices are kept in an array.
vertices point to a linked list of vertices that they are edged with.

3)Modern adjacency list :
its a combination of above 2 approaches
Vertices contain a list of IN and OUT going edges

4)Matrix representation:
creating a new vertex is costly, as 2D matrix is stored in a linear way in computer memory,
so we need to copy and create a new one




BFS :

If graph is considered as tree (root node is considered as starting point node), then bfs:
->traverses over each level of tree one by one (nodes at same level)
->nodes at a distance of 1 edge distance are covered first
->BFS can be implemented as Queue
->The result of BFS is a spanning tree started from node S, such that
spanning tree has minimum path length from node S to any other node.

BFS requires that each node must have 3 more properties other that a normal graph vertex:
1)color		: discovered with processed,undiscovered,discovered with unprocessed
2)parent	: backtrack and get path from any node to S
3)distance	: determines minimum distance from source to any node

Time complexity for BFS = O(V+E)

Breadth First Tree

Applications of BFS :
1)Get no of connected components
2)Bipartite graph :

Every edge has one vertex in set U and other vertex in set W, such that 
U union W = Vertices
U intersection W = nil

Go for a BFS, For a connected graph, graph has no edge in same level during BFS.
If a graph has an edge then it has an odd cycle.
If a graph has an odd cycle, then it is not bipartite.

=>Diameter of BFS = maximum distance bw two vertices in G
=>Distance bw two vertices = length of shortest path bw two vertices

If we want to determine exact diameter of a graph, then we need to perform BFS from every node.
time complexity for this = O(E*V)

Diameter(G) <= 2*(max level no in any BFS)


(Q)seven bridges of konigsberg problem :
If there is a graph G(V,E) , and a user must travel to all nodes without using any edge more than once.

Solution : This can be possible if each vertex have an even degree.


===========================

Depth First Search(DFS) :

DFS can be done on any path of the graph.
There can be many DFS tree possibilities from a single node.
There can be a possibilities that, DFS tree has a longer path bw two nodes as compared to its shortest path.
We store a timestamp of every node.
Every node has two timestamp stored :
	->start_timestamp = time at which node was monitored first.
	->end_timestamp = time at which no further route was found and backtracked.
Stack is used to implement DFS.
Path formed by DFS is called DFS tree.
Two types of edges in DFS tree :
	->tree edges
	->back edges : An edge from a node to its ancestor
A back edge can have a shorter path bw two nodes as compared to tree edges.
DFS has only two types of nodes : tree edge and back edge.


DFS Algo :
DFS can be implemented by using recursion or by stack.

We will use three properties for a node in DFS:
boolean visited		v
int arrival_time	a
int departure_time	d

time=0;
DFS(node) {
	node.v=true;
	node.a=time++;
	for all w adjacent to node {
		If (!w.v) {
			DFS(w);
		}
	}
	node.d=tme++;
}

time complexity = O(E)

property of a DFS :
arr[u] < arr[v]
dep[u] > dep[v]


=======

2 Edge Connected :
A graph is 2 edge connected if and only if, you remove an edge from graph and it is still connected.

bridge edge : an which if removed, then the graph is not a connected.
We just need to find out if there is any bridge edge in a graph

solution 1 : remove each edge and perform BFS and check if graph is connected.

solution 2 :

When backtracking from a node v, 
We need to ensure that there is a back edge from some descendent of v to some ancestor of v.
descendent of v also includes v itself.

There can be many back edges from descendent of v to ancestor of v, but we should be interested in Deepest back edge.
Deepest Back Edge : A back edge whose ancestor arrival time is minimum (i.e. edge goes top of the tree).

variable used in algo :
dbe = deepest back edge

Algo :

time=0;
2EC(node) {
	arr[node]=time++;
	visited[node]=true;
	dbe=arr[node];
	For all w adjacent to node do {
		if(!visited[w]) {
			dbe = min(dbe, 2EC(w));
		} else {
			dbe = min(dbe, arr[w]);
		}
	}
	if(dbe == arr[node]) {
		//graph is not 2 Edge Connected
		Abort;
	}
	return dbe;
}

Two errors in this algo:
->We must not consider dbe for tree edge of node variable.
->The node from which DFS will start, will have a dbe = arr of that node.


(Q)Given a graph G, is G a planar graph?

Planar graph : a graph whose vertices and edges are on same plan and no two edge intersect each other.

Complete graph on 5 vertices, is not a planar graph.

(Q)2 Vertex connected graph :
If we remove a vertex from a graph, the graph must be connected.

===============================

DFS for Directed Graph :

Types of edges :
Forward
Back
Tree
Cross

For cross edge (u,v) :  	arr[u] < dep[u] < arr[v] < dep[v]

For Forward edge (u,v) : 	arr[u] < arr[v]
							dep[u] > dep[v]
								OR
							arr[u] < arr[v] < dep[v] < dep[u]
							
For Back edge (u,v) :		arr[u] > arr[v]
							dep[u] < dep[v]
								OR
							arr[v] < arr[u] < dep[u] < dep[v]
							
For Tree edge (u,v) :		arr[u] < arr[v]
							dep[u] > dep[v]
								OR
							arr[u] < arr[v] < dep[v] < dep[u] (similar to Forward Edge)

Topological sort : sorting vertices on the basis of departure timestamp 
	(this can be done while performing DFS just to avoid complexity of sorting)

A directed graph is cyclic only if it has a back edge :
	

DAG : Directed Acyclic Graph

Strongly connected graph

Weakly connected graph
