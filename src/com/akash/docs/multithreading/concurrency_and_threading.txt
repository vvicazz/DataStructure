Race condition : when multiple processes/threads access same resource and order of accessing resource matters.
Critical section : code that contains race condition

Thread safe : code that has no critical section

all local primitive variable are stored in thread stack
objects are stored in heap, so they can be shared with multiple threads

http://stackoverflow.com/questions/1202444/how-is-javas-threadlocal-implemented-under-the-hood
http://java.dzone.com/articles/painless-introduction-javas-threadlocal-storage

ThreadLocal
WeakRefrences

----------------------------------------------------------------

read-then-modify
check-then-act

intrinsic locks -> every object has its own intrinsic lock

reentrant 
synchronized (1)method , (2)block

race condition
visibility
stale object
long and double in 64 bit environment
volatile

thread confinement
ThreadLocal

Object publication and escape

Immutable objects 

final

combination of immutable and volatile

Two ways to handle concurrency in collection:
(1)throw exception when two threads read/write simultaneously,
this solution is still not thread safe as threads can see stale value.
(2)create new copy of collection while doing any operation, 
as thread will not have any impact on copy.
This might have some performance issues.

CopyOnWriteArrayList
***https://stackoverflow.com/questions/17853112/in-what-situations-is-the-copyonwritearraylist-suitable


NOTE:
we have to apply locking where a shared collection is iterated, to avoid ConcurrentModificationException 
In this example toString() method of HashSet uses iterator
While one thread is iterating over set other thread may add new elements.


====================================
@NotThreadSafe
public class UnsafeSequence {
	private int value;
	/** Returns a unique value. */
	public int getNext() {
		return value++;
	}
}

UnsafeSequence illustrates a common concurrency hazard called a race condition.

@ThreadSafe
public class Sequence {
	@GuardedBy("this") private int value;
	public synchronized int getNext() {
		return value++;
	}
}

Whenever more than one thread accesses a given state variable, and one of them might
write to it, they all must coordinate their access to it using synchronization.

What is thread safety:
No set of operations performed sequentially or concurrently
on instances of a thread-safe class can cause an instance to be in an invalid
state.


A stateless Servlet:

@ThreadSafe
public class StatelessFactorizer implements Servlet {
	public void service(ServletRequest req, ServletResponse resp) {
		BigInteger i = extractFromRequest(req);
		BigInteger[] factors = factor(i);
		encodeIntoResponse(resp, factors);
	}
}


Atomicity:

@NotThreadSafe
public class UnsafeCountingFactorizer implements Servlet {
	private long count = 0;
	public long getCount() { return count; }
	public void service(ServletRequest req, ServletResponse resp) {
		BigInteger i = extractFromRequest(req);
		BigInteger[] factors = factor(i);
		++count;
		encodeIntoResponse(resp, factors);
	}
}

thread 1 : get count(0)		---		inc 0 to 1		----	set count(1)
thread 2 : 							get count(0)	----	inc 0 to 1		---		set count(1)
thread 3 : 													get count(1)	---		inc 1 to 2 		---		set count(2)

it is not atomic, which
means that it does not execute as a single, indivisible operation. Instead, it is a
shorthand for a sequence of three discrete operations: fetch the current value, add
one to it, and write the new value back. This is an example of a read-modify-write
operation, in which the resulting state is derived from the previous state.

read-modify-write causes operations to be non-Atomic.

Race Condition :

The most common
type of race condition is check-then-act, where a potentially stale observation is
used to make a decision on what to do next.

Check-then-Act  problem causes Race Condition in multiple threads.

Race condition can be understood as a problem in which 
reaching the desired outcome depends on the relative timing of events.

This type of race condition
is called check-then-act: you observe something to be true (file X doesn’t
exist) and then take action based on that observation (create X); but in fact the
observation could have become invalid between the time you observed it and the
time you acted on it (someone else created X in the meantime), causing a problem
(unexpected exception, overwritten data, file corruption).

Race Condition in Lazy Initialization:

A common idiom that uses check-then-act is lazy initialization.

@NotThreadSafe
public class LazyInitRace {
	private ExpensiveObject instance = null;
	public ExpensiveObject getInstance() {
		if (instance == null)
			instance = new ExpensiveObject();
		return instance;
	}
}

LazyInitRace has race conditions that can undermine its correctness. Say that
threads A and B execute getInstance at the same time. A sees that instance
is null, and instantiates a new ExpensiveObject. B also checks if instance is
null. Whether instance is null at this point depends unpredictably on timing,
including the vagaries of scheduling and how long A takes to instantiate the ExpensiveObject
and set the instance field.

Compound actions:

@ThreadSafe
public class CountingFactorizer implements Servlet {
	private final AtomicLong count = new AtomicLong(0);
	public long getCount() { return count.get(); }
	public void service(ServletRequest req, ServletResponse resp) {
		BigInteger i = extractFromRequest(req);
		BigInteger[] factors = factor(i);
		count.incrementAndGet();
		encodeIntoResponse(resp, factors);
	}
}


Locking :

@NotThreadSafe
public class UnsafeCachingFactorizer implements Servlet {
	private final AtomicReference<BigInteger> lastNumber
	= new AtomicReference<BigInteger>();
	private final AtomicReference<BigInteger[]> lastFactors
	= new AtomicReference<BigInteger[]>();
	public void service(ServletRequest req, ServletResponse resp) {
		BigInteger i = extractFromRequest(req);
		if (i.equals(lastNumber.get()))
			encodeIntoResponse(resp, lastFactors.get());
		else {
			BigInteger[] factors = factor(i);
			lastNumber.set(i);
			lastFactors.set(factors);
			encodeIntoResponse(resp, factors);
		}
	}
}


The definition of thread safety requires that invariants be preserved regardless
of timing or interleaving of operations in multiple threads. One invariant of UnsafeCachingFactorizer
is that the product of the factors cached in lastFactors
equal the value cached in lastNumber; our servlet is correct only if this invariant
always holds.

An Invariant is a non-changing condition in our program that decides the successful implementation.
here:
last number must be equal multiplication of last factors

Just as AtomicLong is a thread-safe holder class for a long integer, AtomicReference is a threadsafe
holder class for an object reference.



Intrinsic Lock :

A synchronized
block has two parts: a reference to an object that will serve as the lock, and a
block of code to be guarded by that lock. A synchronized method is a shorthand
for a synchronized block that spans an entire method body, and whose lock is
the object on which the method is being invoked. (Static synchronized methods
use the Class object for the lock.)
synchronized (lock) {
// Access or modify shared state guarded by lock
}
Every Java object can implicitly act as a lock for purposes of synchronization;
these built-in locks are called intrinsic locks or monitor locks. The lock is automatically
acquired by the executing thread before entering a synchronized block
and automatically released when control exits the synchronized block, whether
by the normal control path or by throwing an exception out of the block.


Intrinsic locks in Java act as mutexes (or mutual exclusion locks), which means
that at most one thread may own the lock.

@ThreadSafe
public class SynchronizedFactorizer implements Servlet {
	@GuardedBy("this") private BigInteger lastNumber;
	@GuardedBy("this") private BigInteger[] lastFactors;
	public synchronized void service(ServletRequest req,ServletResponse resp) {
		BigInteger i = extractFromRequest(req);
		if (i.equals(lastNumber))
			encodeIntoResponse(resp, lastFactors);
		else {
			BigInteger[] factors = factor(i);
			lastNumber = i;
			lastFactors = factors;
			encodeIntoResponse(resp, factors);
		}
	}
}

This has poor performance.


Reentrant or Reentrancy :

When a thread requests a lock that is already held by another thread, the requesting
thread blocks. But because intrinsic locks are reentrant, if a thread tries
to acquire a lock that it already holds, the request succeeds. Reentrancy means
that locks are acquired on a per-thread rather than per-invocation basis.
When the count is zero, the lock is considered unheld. When a
thread acquires a previously unheld lock, the JVM records the owner and sets the
acquisition count to one. If that same thread acquires the lock again, the count
is incremented, and when the owning thread exits the synchronized block, the
count is decremented. When the count reaches zero, the lock is released.


public class Widget {
	public synchronized void doSomething() {
		...
	}
}

public class LoggingWidget extends Widget {
	public synchronized void doSomething() {
		System.out.println(toString() + ": calling doSomething");
		super.doSomething();
	}
}


A common locking convention is to encapsulate all mutable state within an
object and to protect it from concurrent access by synchronizing any code path
that accesses mutable state using the object’s intrinsic lock. This pattern is used
by many thread-safe classes, such as Vector and other synchronized collection
classes.
Not all data needs to be guarded by locks—only mutable data that will be
accessed from multiple threads.


@ThreadSafe
public class CachedFactorizer implements Servlet {
	@GuardedBy("this") private BigInteger lastNumber;
	@GuardedBy("this") private BigInteger[] lastFactors;
	@GuardedBy("this") private long hits;
	@GuardedBy("this") private long cacheHits;
	public synchronized long getHits() { return hits; }
	public synchronized double getCacheHitRatio() {
		return (double) cacheHits / (double) hits;
	}
	public void service(ServletRequest req, ServletResponse resp) {
		BigInteger i = extractFromRequest(req);
		BigInteger[] factors = null;
		synchronized (this) {
			++hits;
			if (i.equals(lastNumber)) {
				++cacheHits;
				factors = lastFactors.clone();
			}
		}
		if (factors == null) {
			factors = factor(i);
			synchronized (this) {
				lastNumber = i;
				lastFactors = factors.clone();
			}
		}
		encodeIntoResponse(resp, factors);
	}
}

===================================================================================

=====Chapter 3======

synchronized is not only about atomicity or demarcating “critical sections”. Synchronization also
has another significant, and subtle, aspect: memory visibility. We want not only to
prevent one thread from modifying the state of an object when another is using it,
but also to ensure that when a thread modifies the state of an object, other threads
can actually see the changes that were made.

In order to ensure visibility of memory writes across threads, you must use synchronization.

Visibilty :

public class NoVisibility {
	private static boolean ready;
	private static int number;
	private static class ReaderThread extends Thread {
		public void run() {
			while (!ready)
				Thread.yield();
			System.out.println(number);
		}
	}
	public static void main(String[] args) {
		new ReaderThread().start();
		number = 42;
		ready = true;
	}
}



Stale data can cause serious and confusing failures such as unexpected exceptions,
corrupted data structures, inaccurate computations, and infinite loops.

Synchronizing only the setter would not be sufficient: threads calling get 
 would still be able to see stale values.
 

@NotThreadSafe
public class MutableInteger {
	private int value;
	public int get() { return value; }
	public void set(int value) { this.value = value; }
}


@ThreadSafe
public class SynchronizedInteger {
	@GuardedBy("this") private int value;
	public synchronized int get() { return value; }
	public synchronized void set(int value) { this.value = value; }
}

out-of-thin-air safety :

When a thread reads a variable without synchronization, it may see a stale value,
but at least it sees a value that was actually placed there by some thread rather
than some random value.
This safety guarantee is called out-of-thin-air safety.
Out-of-thin-air safety applies to all variables, with one exception: 
64-bit numeric variables (double and long) that are not declared volatile .
 The Java Memory Model requires fetch and store operations to be atomic,
but for nonvolatile long and double variables, the JVM is permitted to treat a
64-bit read or write as two separate 32-bit operations.


Locking and Visibilty :
Intrinsic locking can be used to guarantee that one thread sees the effects of another in a predictable manner.


Volatile variable :

weaker form of synchronization.

When a field is declared volatile, the compiler and runtime
are put on notice that this variable is shared and that operations on it should not
be reordered with other memory operations. Volatile variables are not cached in
registers or in caches where they are hidden from other processors, so a read of a
volatile variable always returns the most recent write by any thread.

When thread A writes to a volatile variable and subsequently
thread B reads that same variable, the values of all variables that were
visible to A prior to writing to the volatile variable become visible to B after
reading the volatile variable.


variables are copied from main memory to cpu cache and then processed by cpu registers.
If we have more than 1 cpu,
then 2 threads processed by different cpu, have different cpu cache for same variable.



____________			_____________________
|			|			|					|
|	CPU	1	|			|	CPU 1 cache  	|
|_Registers_|			|___________________|

												-------------> Main Memory

____________			_____________________
|			|			|					|
|	CPU	2	|			|	CPU 2 cache  	|
|_Registers_|			|___________________|


When not using volatile variable, we do not know when cpu cache value is written back to main memory.

NOTE :
Making a variable volatile is not enough.
If a variable is read and written by many threads, then we may fall in a race condition.
For example Read-Modify-Write scenario.

To overcome this we have 2 solutions:
(1)Use synchronized keyword
(2)Use AtomicLong or AtomicRefrence  which are classes in java.util.concurrent package


----------

Publishing and escape :

Publishing an object means making it available to code outside of its current scope,
such as by storing a reference to it where other code can find it, returning it
from a nonprivate method, or passing it to a method in another class.


-->storing a refrence in public static field

	public static Set<Secret> knownSecrets;
	public void initialize() {
		knownSecrets = new HashSet<Secret>();
	}
	
	
-->Returning a refrence from a non-private method

	class UnsafeStates {
		private String[] states = new String[] {
			"AK", "AL" ...
		};
		public String[] getStates() { return states; }
	}
	
-->Any fields of a nonprivate refrence are also considered as published

-->overridable methods (neither private nor final)

***IMP
-->publish an inner class instance

Do not allow the this reference to escape during construction.

-->Avoid calling thread.start() method from inside the constructor

https://stackoverflow.com/questions/12467101/how-this-escapes-from-a-published-inner-class/12467202#12467202
http://www.ibm.com/developerworks/java/library/j-jtp0618/index.html


public class ThisEscape {

    public Integer i = 47;

    public ThisEscape(EventSource source) {
            source.registerListener(
                    new EventListener() {
                            ThisEscape outerRef = ThisEscape.this;//added by compiler
                            public void onEvent(Event e) {
                                    doSomething(e);
                            }
                    });
    }
}

public class EventSource {
    public void registerListener(EventListener listener) {
        
    }
}


Problem with this approach is that, you can have a situation where inner class will use your class object
 and your class object is still in construction. Same problem exists with starting thread from constructor.
 
class MyThread implements Runnable {
	
	private Thread thread;
	
	MyThread() {
		thread = new Thread(this);	//creating a thread here and passing this is ok,
		thread.start();				//but never start thread in constructor
	}
	
	public void run() {
		...
	}
}

->Never create inner classes in the constructor, either anonymous, local, static or non-static
->Avoid any transitive combination of the rules above, i.e. 
don't create an anonymous inner class in a private or protected final method that is invoked from within the constructor
->Exposing this reference from constructor :
		->setting this in a static field
		->adding this in a collection
		->publishing this via non-static inner class
		

public class Safe { 

  private Object me;
  private Set set = new HashSet();
  private Thread thread;

  public Safe() { 
    // Safe because "me" is not visible from any other thread
    me = this;

    // Safe because "set" is not visible from any other thread
    set.add(this);

    // Safe because MyThread won't start until construction is complete
    // and the constructor doesn't publish the reference
    thread = new MyThread(this);
  }

  public void start() {
    thread.start();
  }

  private class MyThread(Object o) {
    private Object theObject;

    public MyThread(Object o) { 
      this.theObject = o;
    }

    ...
  }
}

public class Unsafe {
  public static Unsafe anInstance;
  public static Set set = new HashSet();
  private Set mySet = new HashSet();

  public Unsafe() {
    // Unsafe because anInstance is globally visible
    anInstance = this;

    // Unsafe because SomeOtherClass.anInstance is globally visible
    SomeOtherClass.anInstance = this;

    // Unsafe because SomeOtherClass might save the "this" reference
    // where another thread could see it
    SomeOtherClass.registerObject(this);

    // Unsafe because set is globally visible 
    set.add(this);

    // Unsafe because we are publishing a reference to mySet
    mySet.add(this);
    SomeOtherClass.someMethod(mySet);

    // Unsafe because the "this" object will be visible from the new
    // thread before the constructor completes
    thread = new MyThread(this);
    thread.start();
  }

  public Unsafe(Collection c) {
    // Unsafe because "c" may be visible from other threads
    c.add(this);
  }
}


Thread Confinement :

https://www.quora.com/Java-programming-language/What-are-some-tips-tricks-and-gotchas-when-using-ThreadLocal
http://stackoverflow.com/questions/11283369/how-does-threadlocal-usage-reduce-reusability

/**
*	Every thread has its own map
*	key of map = threadlocal object
*	value of map = value to be stored in threadlocal
*/

class Thread {
	ThreadLocal.ThreadLocalMap threadLocals = null;
}

class ThreadLocal {
	
	static class ThreadLocalMap {
		private Entry[] table;
		static class Entry extends WeakReference<ThreadLocal<?>> {
			Object value;
		}
	}
	
	public T get() {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = t.threadLocals;
        ThreadLocalMap.Entry e = map.get(this);
        return e.value;
	}

	public void set(T value) {
		Thread t = Thread.currentThread();
		ThreadLocalMap map = t.threadLocals;
		map.set(this, value);
	}
	
	public void remove() { 
		Thread t = Thread.currentThread();
		ThreadLocalMap map = t.threadLocals;
		map.set(this);
	}
}

It is easy to abuse ThreadLocal by treating its thread confinement property as
a license to use global variables or as a means of creating “hidden” method arguments.
Like global variables, thread-local variables can detract from reusability
and introduce hidden couplings among classes, and should therefore be used
with care.

Immutable Objects :

Immutable objects are always thread-safe.
Their invariants are established by the constructor, 
and if their state cannot be changed, these invariants always hold.

Whenever a group of related data items must
be acted on atomically, consider creating an immutable holder class for them,
such as OneValueCache.

@Immutable
class OneValueCache {
	private final BigInteger lastNumber;
	private final BigInteger[] lastFactors;
	public OneValueCache(BigInteger i,
	BigInteger[] factors) {
		lastNumber = i;
		lastFactors = Arrays.copyOf(factors, factors.length);
	}
	public BigInteger[] getFactors(BigInteger i) {
		if (lastNumber == null || !lastNumber.equals(i))
			return null;
		else
			return Arrays.copyOf(lastFactors, lastFactors.length);
	}
}

@ThreadSafe
public class VolatileCachedFactorizer implements Servlet {
	private volatile OneValueCache cache = new OneValueCache(null, null);
	public void service(ServletRequest req, ServletResponse resp) {
		BigInteger i = extractFromRequest(req);
		BigInteger[] factors = cache.getFactors(i);
			if (factors == null) {
				factors = factor(i);
				cache = new OneValueCache(i, factors);
			}
		encodeIntoResponse(resp, factors);
	}
}

Immutable and Affectively immutable classes :

http://stackoverflow.com/questions/16678416/different-between-immutable-and-effectively-immutable-objects

Affectively Immutable class is when class has mutable instance variables but are not published as public.
for eg , having a ArrayList in a class and returning its copy from getter method.
Or having a mutable object with returning its copy from getter.

Truly Immutable class is when all its instance variables are immutable.

properties of Immutable class :
->setting all instance variables in constructor
->removing setters
->passing copy of mutable object from getter method
->making class final
->hashcode of immutable objects must be cashed



====================================================================================================
http://www.programmr.com/blogs/what-every-java-developer-should-know-strong-and-weak-references
https://web.archive.org/web/20061130103858/http://weblogs.java.net/blog/enicholas/archive/2006/05/understanding_w.html

** strong, soft, weak, and phantom, in order from strongest to weakest

=>Strong References :

	Widget w = new Widget();

A Widget object is created on the heap, and the variable w holds a reference to that object. 
As long as the variable w is active, the object which it points to (Widget) will not be garbage collected.
That is why this is known as Strong Reference.
Strong because the object referenced by it cannot be garbage collected against its will.


=>Weak References :

Objects referenced by Weak Reference may be garbage collected,
if the JVM runs short of memory, even when they are being used.
 
WeakReference<String> wr = new WeakReference<String>(new String("abc"));

	String s = wr.get();
	if(s != null ) {
	    // great the weak ref has not been garbage collected
	} else {
	    // oops the weak ref was garbage collected... now I will have to create another one
	}
	
The most common use for weak references are read-only caches, where losing an object is not disastrous.
We can also use WeakHashMap for these kind of caches.

====================================================================================================

Spring transactions
Refrences in java

============Chapter 4===========

The design process for a thread-safe class should include these three basic elements:
• Identify the variables that form the object’s state;
• Identify the invariants that constrain the state variables;
• Establish a policy for managing concurrent access to the object’s state.



==========================================================================================================

============Chapter 5===========

=>Problems with synchronised collections

when there is a gap b/w locking state of object and synchronization methods

=>Iterators and ConcurrentModificationException

The standard way to iterate a Collection is with an Iterator, 
either explicitly or through the for-each loop syntax introduced in Java 5.0.

The iterators returned by the synchronized collections are not designed to deal with concurrent modiﬁcation,
 and they are fail-fast—meaning that if they detect that the collection has changed since iteration began,
 they throw the unchecked ConcurrentModificationException. 

classes like Vector has fail fast iterators
to avoid ConcurrentModificationException, a lock should be applied before iterator
Another way of iterating is to first make a copy of collection

copy cost performance
locking cost time wait for other threads

=>Hidden iterators

greater the distance between the state and the synchronization that guards it, 
the more likely that someone will forget to use proper synchronization when accessing that state. 

methods like toString(), equals(), hashcode() or any other


=>Concurrent Collection

 Synchronized collections achieve their thread safety by serializing all access to the collection’s state. 
 The cost of this approach is poor concurrency; 
 when multiple threads contend for the collection-wide lock, throughput suffers. 

ConcurrentHashMap  -- synchronised hashMap -- hashMap
CopyOnWriteArrayList  --  synchronised list  -- ArrayList
ConcurrentSkipListMap  --  TreeMap
ConcurrentSkipListSet  --  TreeSet

Queue -- operations and not blocked
	linkedList
BlockingQueue  -- operations are blocked
	LinkedBlockingQueue


=>ConcurrentHashMap


Types of Iterators :

fail fast
	-> iterators throw ConcurrentModificationException when any modification done in 
		collection after creating iterator.
	-> eg: ArrayList, LinkedList
fail safe 
	-> The term "fail-safe" isn't used anywhere in official Java documentation
	-> iterators do not throw ConcurrentModificationException
	-> CopyOnWriteArrayList, CopyOnWriteArraySet
	-> whenever collection is modified(element added or removed), a new copy is created
		and while creating an iterator, snapshot of collection is taken
		so any modification on collection will not impact on this snapshot 
	-> The only guarantee is that the elements seen by the iteration were present in the input at some point.
		That's a pretty weak guarantee.
		
weakly consistent
	-> iterators do not throw ConcurrentModificationException
	-> ConcurrentHashMap
	-> they are guaranteed to traverse elements as they existed upon construction exactly once, 
		and may (but are not guaranteed to) reflect any modifications subsequent to construction.
		
		
		
**fail fast iteration
	List<String> input = Arrays.asList("a", "b", "c", "d", "e");
	List<String> output = new ArrayList<>();

	Deque<String> deque = new LinkedList<>(input);
	for (String s : deque) {
		output.add(s);
		if (s.equals("c")) {
			deque.addFirst("XXX");
			deque.removeLast();
		}
	}
	
	//ConcurrentModificationException at runtime
	
**weakly consistent iteration
	List<String> input = Arrays.asList("a", "b", "c", "d", "e");
	List<String> output = new ArrayList<>();

	Deque<String> deque = new ConcurrentLinkedDeque<>(input);
	for (String s : deque) {
		output.add(s);
		if (s.equals("c")) {
			deque.addFirst("XXX");
			deque.removeLast();
		}
	}
	
	//the output list is [a, b, c, d]
	 the output list reflects only some of the modifications that were made to the input during the iteration

**for loop with index (different from iterator)
	List<String> input = Arrays.asList("a", "b", "c", "d", "e");
    List<String> output = new ArrayList<>();

    List<String> arrayList = new ArrayList<>(input);
    for (int i = 0; i < arrayList.size(); i++) {
        String s = arrayList.get(i);
        output.add(s);
        if (i == 2) {                   // <<< MODIFY
            arrayList.add(0, "XXX");
        }
    }
	
	// the output list is [a, b, c, c, d, e]
	
	 
	Weakly consistent iteration provides guarantees against repeated elements and 
	against a variety of errors or infinite loops that can occur. 
	The "weakness" is that they provide few guarantees about exactly which elements are observed during iteration.
	
https://stackoverflow.com/questions/28915215/iterator-type-in-java-weakly-consistent?rq=1
https://stackoverflow.com/questions/20142493/fail-safe-iterators-and-weakly-consistent-iterators


(Q) How ConcurrentHashMap calculates its size?
It can use AtomicLong for this operation
but it uses CounterCell which is adapted for LongAdder and Striped64


=>CopyOnWriteArrayList 

copy-on-write collections
	->when traversal operations vastly outnumber mutations
	->when you cannot or don't want to synchronize traversals
	->"snapshot" style iterator method, reference to the state of the collection at the point that the iterator was created
	->iterator will never throw ConcurrentModificationException
	->Not good for frequent modification in collection
	

This criterion exactly describes many event-notiﬁcation systems:
 delivering a notiﬁcation requires iterating the list of registered listeners and calling each one of them,
 and in most cases registering or unregistering an event listener is far less 
 common than receiving an event notiﬁcation. 
 
 
=>Blocking queues and the producer-consumer pattern

 The producer consumer pattern simpliﬁes development because it removes code dependencies
 between producer and consumer classes, and simpliﬁes workload management by
 decoupling activities that may produce or consume data at different or variable rates. 

Bounded queues are a powerful resource management tool for building reliable applications: 
they make your program more robust to overload by throttling activities that threaten 
to produce more work than can be handled.



=>Blocking and interruptible methods


public void interrupt() {
	synchronized (blockerLock) {
		Interruptible b = blocker;
		if (b != null) {
			interrupt0();           // Just to set the interrupt flag
			b.interrupt(this);
			return;
		}
	}
	interrupt0();
}

->If this thread is blocked in an invocation of the wait(), join(), sleep(long) methods,
	then its interrupt status will be cleared and it will receive an InterruptedException.
->If this thread is blocked in an I/O operation upon an InterruptibleChannel then
	the channel will be closed, the thread's interrupt status will be set, and 
	the thread will receive a java.nio.channels.ClosedByInterruptException. 
->If none of the previous conditions hold then this thread's interrupt status will be set. 

=====================================================

//true if this thread has been interrupted; false otherwise.
//The interrupted status of the thread is cleared by this method.
//if there is an interrupt, then first call will return true and status is cleared
//second call will return false.

public static boolean interrupted() {
	return currentThread().isInterrupted(true);
}

=====================================================

//true if this thread has been interrupted; false otherwise.
//The interrupted status of the thread is unaffected by this method

public boolean isInterrupted() {
	return isInterrupted(false);
}

=====================================================

/**
 * Tests if some Thread has been interrupted.  The interrupted state
 * is reset or not based on the value of ClearInterrupted that is
 * passed.
 */
private native boolean isInterrupted(boolean ClearInterrupted);

=====================================================

private native void interrupt0();

=====================================================

When a method can throw InterruptedException, it is telling you that it is a blocking method,
 and further that if it is interrupted, it will make an effort to stop blocking early.
 Thread provides the interrupt method for interrupting a thread
 and for querying whether a thread has been interrupted.
 Each thread has a boolean property that represents its interrupted status;
 interrupting a thread sets this status.
 Interruption is a cooperative mechanism.
 One thread cannot force another to stop what it is doing and do something else;
 when thread A interrupts thread B, A is merely requesting that B stop what it is doing
 when it gets to a convenient stopping point—if it feels like it. 
 
 When your code calls a method that throws InterruptedException, 
 then your method is a blocking method too, and must have a plan for responding to interruption.
 For library code, there are basically two choices
 1) Propagate the InterruptedException
	just propagate the InterruptedException to your caller. 
	->not catching InterruptedException
	->catching it and throwing it again after performing some brief activity-speciﬁc cleanup
2) Restore the interrupt
	you must catch InterruptedException and restore the interrupted status by calling interrupt
	on the current thread, so that code higher up the call stack can see that an interrupt was issued

	public class TaskRunnable implements Runnable {
		...
		public void run() {
			try {
				processTask(queue.take()); 
			} catch (InterruptedException e) { 
				// restore interrupted status 
				Thread.currentThread().interrupt(); 
			} 
		}
	}
	


=>Synchronizers

--->Latches
A latch is a synchronizer that can delay the progress of threads until it reaches its terminal state. 
A latch acts as a gate:
Once the latch reaches the terminal state, it cannot change state again, so it remains open forever

eg :
 ->Waiting until all the parties involved in an activity, 
 for instance the players in a multi-player game, are ready to proceed
 
 ->how long it takes to run a task n times concurrently
 
The countDown() method decrements the counter, indicating that an event has occurred, 
and the await() methods wait for the counter to reach zero, 
which happens when all the events have occurred. 
If the counter is nonzero on entry, await blocks until the counter reaches zero,
 the waiting thread is interrupted, or the wait times out. 
 
 
--->FutureTask

states : 	waiting to run
			Running
			Completed
				->completion
				->cancellation
				->Exception
				
 Once a FutureTask enters the completed state, it stays in that state forever. 
 FutureTask is used by the Executor framework to represent asynchronous tasks.
 

--->Semaphores 

--->Barriers 


=>Building an efﬁcient, scalable result cache

***Memoizer1

public interface Computable<A, V> {
	V compute(A arg) throws InterruptedException; 
}
public class ExpensiveFunction implements Computable<String, BigInteger> {
	public BigInteger compute(String arg) {
		// after deep thought... 
		return new BigInteger(arg); 
	}
}
public class Memoizer1<A, V> implements Computable<A, V> {
	@GuardedBy("this") 
	private final Map<A, V> cache = new HashMap<A, V>(); 
	private final Computable<A, V> c;
	public Memoizer1(Computable<A, V> c) {
		this.c = c;
	}
	public synchronized V compute(A arg) throws InterruptedException {
		V result = cache.get(arg);
		if (result == null) {
			result = c.compute(arg);
			cache.put(arg, result);
		}
		return result;
	}
}


***Memoizer2

public class Memoizer2<A, V> implements Computable<A, V> {
	private final Map<A, V> cache = new ConcurrentHashMap<A, V>();
	private final Computable<A, V> c;
	public Memoizer2(Computable<A, V> c) {
		this.c = c;
	}
	public V compute(A arg) throws InterruptedException {
		V result = cache.get(arg);
		if (result == null) {
			result = c.compute(arg);
			cache.put(arg, result);
		}
		return result;
	}
}



***Memoizer3

public class Memoizer3<A, V> implements Computable<A, V> {
	private final Map<A, Future<V>> cache = new ConcurrentHashMap<A, Future<V>>();
	private final Computable<A, V> c;
	public Memoizer3(Computable<A, V> c) {
		this.c = c;
	}
	public V compute(final A arg) throws InterruptedException {
		Future<V> f = cache.get(arg);
		if (f == null) {
			Callable<V> eval = new Callable<V>() {
				public V call() throws InterruptedException { 
					return c.compute(arg); 
				} 
			}; 
			FutureTask<V> ft = new FutureTask<V>(eval);
			f = ft;
			cache.put(arg, ft);
			ft.run(); // call to c.compute happens here 
		} 
		try { 
			return f.get(); 
		} catch (ExecutionException e) { 
			throw launderThrowable(e.getCause()); 
		} 
	}
}



***Memoizer4

public class Memoizer<A, V> implements Computable<A, V> {
	private final ConcurrentMap<A, Future<V>> cache = new ConcurrentHashMap<A, Future<V>>(); 
	private final Computable<A, V> c;
	public Memoizer(Computable<A, V> c) { 
		this.c = c; 
	}
	public V compute(final A arg) throws InterruptedException {
		while (true) {
			Future<V> f = cache.get(arg); 
			if (f == null) { 
				Callable<V> eval = new Callable<V>() {
					public V call() throws InterruptedException { 
						return c.compute(arg); 
					} 
				}; 
				FutureTask<V> ft = new FutureTask<V>(eval);
				f = cache.putIfAbsent(arg, ft);
				if (f == null) {
					f = ft; 
					ft.run();
				} 
			} 
			try { 
				return f.get(); 
			} catch (CancellationException e) { 
				cache.remove(arg, f); 
			} catch (ExecutionException e) { 
				throw launderThrowable(e.getCause()); 
			} 
		} 
	}
}



@ThreadSafe 
public class Factorizer implements Servlet { 
	private final Computable<BigInteger, BigInteger[]> c = new Computable<BigInteger, BigInteger[]>() {
		public BigInteger[] compute(BigInteger arg) {
			return factor(arg); 
		} 
	}; 
	private final Computable<BigInteger, BigInteger[]> cache = new Memoizer<BigInteger, BigInteger[]>(c);
	public void service(ServletRequest req, ServletResponse resp) {
		try {
			BigInteger i = extractFromRequest(req); 
			encodeIntoResponse(resp, cache.compute(i)); 
		} catch (InterruptedException e) {
			encodeError(resp, "factorization interrupted"); 
		}
	}
}



=>Summary 

• It’s the mutable state, stupid.1 All concurrency issues boil down to coordinating access to mutable state.
 The less mutable state, the easier it is to ensure thread safety.

 • Make ﬁelds ﬁnal unless they need to be mutable.

 • Immutable objects are automatically thread-safe. Immutable objects simplify concurrent programming tremendously. They are simpler and safer, and can be shared freely without locking or defensive copying.

 • Encapsulation makes it practical to manage the complexity. You could write a thread-safe program with all data stored in global variables, but why would you want to? Encapsulating data within objects makes it easier to preserve their invariants; encapsulating synchronization within objects makes it easier to comply with their synchronization policy.

 • Guard each mutable variable with a lock.

 • Guard all variables in an invariant with the same lock.

 • Hold locks for the duration of compound actions.

 • A program that accesses a mutable variable from multiple threads without synchronization is a broken program.

 • Don’t rely on clever reasoning about why you don’t need to synchronize.

 • Include thread safety in the design process—or explicitly document that your class is not thread-safe.

 • Document your synchronization policy.


==========================================================================================================


